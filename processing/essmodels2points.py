# -*- coding: utf-8 -*-

"""
/***************************************************************************
 smk_tools
                                 A QGIS plugin
 Suomen metsäkeskuksen työkalut
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-10-04
        copyright            : (C) 2022 by Suomen metsäkeskus
        email                : mikko.kesala@metsakeskus.fi
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Suomen metsäkeskus'
__date__ = '2022-10-04'
__copyright__ = '(C) 2022 by Suomen metsäkeskus'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'
from stat import S_ISLNK
from qgis import processing
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication,QVariant
from qgis.core import (QgsProcessing,QgsProcessingParameterField,
                       QgsField,QgsProcessingParameterBoolean,
                       QgsFeatureSink,
                       QgsProcessingParameterFeatureSource,QgsProcessingParameterRasterLayer,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterMapLayer,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterDefinition,
                       QgsProcessingUtils,QgsRasterLayer,QgsVectorLayer)
import os,time,sys
sys.path.append(os.path.dirname(__file__))
#from PIL import Image
from getInput import getWebRasterLayer,getWebVectorLayer,getProtectedSites
from smk_geotools import feature2Layer,createTreeMap,addFieldValue,joinIntersection
from smk_essmodels import runEssModel
#from saastopuu import *
pluginPath = os.path.abspath(
    os.path.join(
        os.path.dirname(__file__),
        os.pardir))

class essmodels2points(QgsProcessingAlgorithm):


    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    FOSFORI = 'FOSFORI'
    DTW = 'DTW'
    BIOD = 'BIOD'
    LAHOP = 'LAHOP'
    PUUM = 'PUUM'

    chm_data = 'https://avoin.metsakeskus.fi/rajapinnat/v1/CHM_newest/ows?'
    grid_data = 'https://avoin.metsakeskus.fi/rajapinnat/v1/gridcell/ows?'
    stand_data = 'https://avoin.metsakeskus.fi/rajapinnat/v1/stand/ows?'
    dtw_data = 'https://paituli.csc.fi/geoserver/paituli/wcs?'
    mkasviv_data = 'https://paikkatieto.ymparisto.fi/arcgis/rest/services/INSPIRE/SYKE_EliomaantieteellisetAlueet/MapServer/0'
    euc_data = 'https://aineistot.metsakeskus.fi/metsakeskus/rest/services/Vesiensuojelu/euclidean/ImageServer'
    
    stand_name = 'stand'
    gname = 'gridcell'
    dtw_name = 'paituli:luke_dtw_04'
    mkasviv_name = 'eliogeoalue'

    stand_fields = 'SPECIALFEATURECODE,SPECIALFEATUREADDITIONALCODE,GEOMETRY'
    grid_fields = 'GEOMETRY,FERTILITYCLASS,DEVELOPMENTCLASS,STEMCOUNTPINE,STEMCOUNTDECIDUOUS,STEMCOUNTSPRUCE,MEANDIAMETERDECIDUOUS,MEANDIAMETERPINE,MEANDIAMETERSPRUCE,MEANHEIGHTDECIDUOUS,MEANHEIGHTPINE,MEANHEIGHTSPRUCE'
    mkasviv_fields = 'PaajakoNro,Nimi'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """
        self.addParameter(QgsProcessingParameterFeatureSource('points', 'points', types=[QgsProcessing.TypeVectorPoint], defaultValue=None))
        self.addParameter(QgsProcessingParameterField('diameter', 'diameter', type=QgsProcessingParameterField.Numeric, parentLayerParameterName='points', allowMultiple=False, defaultValue='diameter'))
        self.addParameter(QgsProcessingParameterField('species', 'species', type=QgsProcessingParameterField.Numeric, parentLayerParameterName='points', allowMultiple=False, defaultValue='species'))
        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(QgsProcessingParameterFeatureSource('cutting', 'cutting', types=[QgsProcessing.TypeVectorPolygon], defaultValue=None))
       
        

        self.addParameter(QgsProcessingParameterBoolean('hotspot', 'calculate hotspot', defaultValue=True))
        #self.addParameter(QgsProcessingParameterRasterDestination('LeikattuLatvus', 'leikattu latvus', createByDefault=True, defaultValue=None))
        #self.addParameter(QgsProcessingParameterFeatureSink('LeikattuHila', 'Leikattu hila', type=QgsProcessing.TypeVectorAnyGeometry, createByDefault=True, defaultValue=None))
        params = []

        params.append(
            QgsProcessingParameterEnum(
                self.FOSFORI,
                self.tr('Ravinteiden pidättyminen'),
                options=['Ei painotusta','Pieni','Keskimääräinen','Suuri'],
                defaultValue=1
            )
            )

        params.append(
            QgsProcessingParameterEnum(
                self.DTW,
                self.tr('Maaperän kosteus'),
                options=['Ei painotusta','Pieni','Keskimääräinen','Suuri'],
                defaultValue=1
            )
            )

        params.append(
            QgsProcessingParameterEnum(
                self.BIOD,
                self.tr('Puuston monimuotoisuus'),
                options=['Ei painotusta','Pieni','Keskimääräinen','Suuri'],
                defaultValue=1
            )
            )

        params.append(
            QgsProcessingParameterEnum(
                self.LAHOP,
                self.tr('Lahopuupotentiaali'),
                options=['Ei painotusta','Pieni','Keskimääräinen','Suuri'],
                defaultValue=1
            )
            )
        

        for p in params:
            p.setFlags(p.flags() | QgsProcessingParameterDefinition.FlagAdvanced) 
            self.addParameter(p)

        self.addParameter(
            QgsProcessingParameterNumber(
                self.PUUM,
                self.tr('Säästöpuiden määrä (kpl /ha)'),
                type=QgsProcessingParameterNumber.Integer,
                minValue=5,maxValue=30,defaultValue=10
            )
            )

        # We add a feature sink in which to store our processed features (this
        # usually takes the form of a newly created vector layer when the
        # algorithm is run in QGIS).
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('points')
            )
        )
    def processAlgorithm(self, parameters, context, feedback):
            """
            Here is where the processing itself takes place.
            """
            feedb = {1:feedback.setProgressText,
                    2:feedback.pushWarning,
                    3:feedback.reportError}
            # Retrieve the feature source and sink. The 'dest_id' variable is used
            # to uniquely identify the feature sink, and must be included in the
            # dictionary returned by the processAlgorithm function.
            source = self.parameterAsSource(parameters, self.INPUT, context)

            if parameters['hotspot']==True:
                features = source.getFeatures()
                
                chm = getWebRasterLayer(out,self.chm_data,"")
                feedb[chm[2]](chm[1])
                stand = getWebVectorLayer(out,self.stand_data,self.stand_name,self.stand_fields)
                feedb[stand[2]](stand[1])

                fgrid = getWebVectorLayer(out,self.grid_data,self.gname,self.grid_fields)
                feedb[fgrid[2]](fgrid[1])

                dtw = getWebRasterLayer(out,self.dtw_data,self.dtw_name)
                feedb[dtw[2]](dtw[1])

                biogeo = getWebVectorLayer(out,self.mkasviv_data,self.mkasviv_name,self.mkasviv_fields)
                feedb[biogeo[2]](biogeo[1])

                euc = getWebRasterLayer(out,self.euc_data,"")
                feedb[euc[2]](euc[1])
    